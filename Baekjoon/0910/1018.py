# MN개의 단위 정사각형으로 나누어져 있는 MxN 크기의 보드에
# 어떤 정사각형은 검은색으로 칠해져있고 나머지는 흰색으로 칠해져 있다
# 이 보드를 잘라서 8x8 크기의 체스판으로 만들려고 한다
# 체스판은 검은색과 흰색이 번갈아서 칠해져 있어야 한다.
# 각 칸이 검은색과 흰색 중 하나로 색칠되어 있고
# 변을 공유하는 두 개의 사각형은 다른 색으로 칠해져 있어야 한다
# 이 정의를 따르면 체스판을 색칠하는 경우는 두 가지 뿐이다
# 하나는 맨 왼쪽 위 칸이 흰색인 경우, 하나는 검은색인 경우이다
# 보드가 체스판처럼 칠해져 있다는 보장이 없어서
# 8x8 크기의 체스판으로 잘라낸 후에 몇 개의 정사각형을
# 다시 칠해야겠다고 생각했다
# 8x8 크기는 아무데서나 골라도 된다
# 다시 칠해야 하는 정사각형의 최소 개수를 구하는 프로그램 작성

# 첫째 줄에 N과 M이 주어진다
# N과 M은 8보다 크거나 같고 50보다 작거나 같은 자연수
# 둘째 줄부터 N개의 줄에는 보드의 각 행의 상태가 주어진다
# B는 검은색, W는 흰색

# 첫째 줄에 다시 칠해야 하는 정사각형 개수의 최솟값 출력

n, m = map(int, input().split())
# 원래의 체스판을 저장하기 위한 리스트
original = []
# 바뀐 체스판의 개수를 저장하기 위한 리스트
count =[]

# n(행)의 개수만큼 원래의 판을 입력 받음
for _ in range(n):
    original.append(input())

# 가능한 모든 경우의 수를 체크하기 위해 4중 for문 사용
# 첫번째, 두번째 for문은 전체 체스판에서 시작점을 잡기 위한 반복문
# x는 행, y는 열에 대해 원래 체스판에서 8x8로 자를 수 있는 범위의 시작점
for x in range(n - 7):
    for y in range(m -7):
        # 'W'로 시작할 경우 바뀐 체스판의 개수를 세기 위함
        index1 = 0
        # 'B'로 시작할 경우 바뀐 체스판의 개수를 세기 위함
        index2 = 0
        
        # 행과 열의 시작점 x, y를 기준으로 8칸씩 모두 체크
        # 현재 행의 번호 i, 현재 열의 번호 j의 합이 짝수이면 시작점의 색깔과 같아야 하고
        # 홀수이면 시작점의 색깔과 다른 색이어야 한다
        for i in range(x, x + 8):
            for j in range(y, y + 8):
                # i + j의 값이 짝수인 경우
                if (i + j) % 2 == 0:
                    # W가 아니라면 index1에 1을 더하고
                    if original[i][j] != 'W':
                        index1 += 1
                    # B가 아니라면 index2dp 1을 더한다
                    elif original[i][j] != 'B':
                        index2 += 1
                # i + j의 값이 홀수인 경우
                # 시작점의 색깔과 다르지 않은 경우 체크
                else:
                    if original[i][j] != 'B':
                        index1 += 1
                    elif original[i][j] != 'W':
                        index2 += 1
        # W로 시작할 경우와 B로 시작할 경우
        # 바뀐 체스판의 수 중 작은 수를 리스트 count에 더한다
        count.append(min(index1, index2))

# 모든 경우의 수를 다 체크하고 count 중 제일 작은 수 출력
print(min(count))