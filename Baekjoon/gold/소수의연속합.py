# 1644

# 하나 이상의 연속된 소수의 합으로 나타낼 수 있는 자연수들이 있다
# 몇가지 자연수의 예를 들어 보면 다음과 같다
# 3 : 3 (한 가지)
# 41 : 2 + 3 + 5 + 7 + 11 + 13 = 11 + 13 + 17 = 41(세 가지)
# 53 : 5 + 7 + 11 + 13 + 17 = 53 (두 가지)
# 하지만 연속된 소수의 합으로 나타낼 수 없는 자연수들도 있는데
# 20이 그 예이다. 7 + 13을 계산하면 20이 되기는 하나 7과 13이
# 연속이 아니기에 적합한 표현이 아니다
# 또한 한 소수는 반드시 한 번만 덧셈에 사용할 수 있기 때문에
# 3 + 5 + 5 + 7과 같은 표현도 적합하지 않다
# 자연수가 주어졌을 때 이 자연수를 연속된 소수의 합으로
# 나타낼 수 있는 경우의 수를 구하라

# 첫째 줄에 자연수 N이 주어진다

# 첫째 줄에 자연수 N을 연속된 소수의 합으로 나타낼 수 있는
# 경우의 수 출력

import sys

N = int(sys.stdin.readline())
# 소수 판별 리스트 초기화
# 인덱스 0, 1은 False(소수 아님)
# 나머지 인덱스는 True(소수)
li = [False, False] + [True] * (N - 1)
# 소수 리스트 초기화
num = []
for i in range(2, N + 1):
    if li[i]:
        num.append(i)
        # 현재 소수의 배수는 소수가 아니므로 False 처리
        for j in range(2 * i, N + 1, i):
            li[j] = False
ans = 0
start = 0
end =0
# 현재 구간 합 계산
while end <= len(num):
    sum_ = sum(num[start:end])
    # 구간 합이 N과 같으면 경우의 수 1 증가
    if sum_ == N:
        ans += 1
        end += 1
    # 구간 합이 N보다 작으면 end를 증가시켜 구간을 늘림
    elif sum_ < N:
        end += 1
    # 구간 합이 N보다 크면 start를 증가시켜 구간을 줄임
    else:
        start += 1
print(ans)        



# 에라토스테네스의 체를 이용해 주어진 자연수 N까지의
# 모든 소수를 구한 뒤 구간 합을 구해서 주어진 수 N을 만들 수 있는
# 연속된 소수의 개수를 구하는 문제
# 에라토스테네스의 체 알고리즘은 주어진 범위 내에서 모든 소수를
# 찾을 때 사용하는 대표적인 방법 중 하나이다
# 에라토스테네스의 체 알고리즘을 활용해 2부터 N까지의 모든 소수를
# 찾고 그 소수들을 리스트 num에 저장한다
# 그 다음 리스트 num에서 연속된 소수의 합이 N이 되는 경우의 수를
# 찾기 위해 투 포인터 알고리즘을 활용한다
# 투 포인터 알고리즘은 리스트 내에서 양쪽 끝에서 시작해
# 두 개의 포인터를 이용해 원하는 조건을 만족하는 구간을 찾는 알고리즘
# 리스트 num에서 start와 end라는 두 개의 포인터를 이용해
# start부터 end까지의 구간 합을 구하고 이 합이 N과 같으면
# end를 증가시키면서 경우의 수를 찾아내고 만약 합이 N보다 작으면
# end를 증가시켜 구간을 확장하고, 합이 N보다 크면 start를 증가시켜
# 구간을 좁혀가면서 경우의 수를 찾아낸다
# 결과적으로 에라토스테네스의 체 알고리즘과 투 포인터 알고리즘을
# 이용해 1부터 N까지의 모든 소수를 찾고 그 소수들 중에서
# 연속된 소수의 합이 N이 되는 경우의 수를 구하는 효율적인 코드이다