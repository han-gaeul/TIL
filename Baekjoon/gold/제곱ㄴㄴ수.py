# 1016

# 어떤 정수 X가 1보다 큰 제곱수로 나누어 떨어지지 않을 때
# 그 수를 제곱ㄴㄴ수라고 한다. 제곱수는 정수의 제곱이다
# min과 max가 주어지면 min보다 크거나 같고 max보다 작거나 같은
# 제곱ㄴㄴ수가 몇 개 있는지 출력

# 첫째 줄에 두 정수 min과 max가 주어진다

# 첫째 줄에 min보다 크거나 같고 max보다 작거나 같은
# 제곱ㄴㄴ수의 개수를 출력

mn, mx = map(int, input().split())
# mn부터 mx까지의 모든 수가 소수인지 아닌지 나타낼 리스트 생성
arr = [1] * (mx - mn + 1)
# 2부터 mx의 제곱근까지의 모든 수에 대해서
# i의 제곱수의 배수를 모두 걸러냄
for i in range(2, int(mx ** 0.5) + 1):
    t = i ** 2
    # mn에서 t의 배수 중 가장 작은 수부터 mx까지 t씩 증가하며
    for j in range(mn // t * t, mx + 1, t):
        # arr[j - mn]이 1인 경우 즉, arr[j - mn]번째 원소가 1인 경우
        if j - mn >= 0 and arr[j - mn]:
            # arr[j - mn]을 0으로 변경
            # mn에서 mx까지의 t의 배수들은 모두 0으로 변경되어
            # 소수가 아님을 표시
            arr[j - mn] = 0
# 값이 1인 원소의 개수를 출력
# 이 값은 mn부터 mx까지의 소수의 개수를 나타냄
print(arr.count(1))


# 특정 범위 안에 있는 소수의 개수를 구하는 문제
# 일반적인 소수 판별 알고리즘을 이용하면 범위 안에 있는
# 모든 수를 하나씩 판별해야 하기 때문에 시간복잡도가 매우 커지게 됨
# 때문에 에라토스테네스의 체 알고리즘을 활용해
# 주어진 범위 내에서 소수를 찾아내고, 이 소수들의 개수를
# 구하는 방식으로 문제를 해결한다
# 범위 내의 모든 수에 대해서 소수 여부를 표시하는 arr 리스트를 만들고
# 이 리스트에서 소수가 아닌 수들을 걸러내는 방식으로 소수를 찾는다