# 1715

# 정렬된 두 묶음의 숫자 카드가 있다고 하자. 각 묶음의 카드의 수를
# A, B라 하면 보통 두 묶음을 합쳐서 하나로 만드는 데에는
# A + B번의 비교를 해야 한다. 이를테면, 20장의 숫자 카드 묶음과
# 30장의 숫자 카드 묶음을 합치려면 50번의 비교가 필요하다.
# 매우 많은 숫자 묶음이 책상 위에 놓여있다. 이들을 두 묶음씩 골라
# 서로 합쳐나간다면, 고르는 순서에 따라서 비교 횟수가 매우 달라진다
# 예를 들면 10장, 20장, 40장의 묶음이 있다면 10장과 20장을 합친 뒤,
# 합친 30장 묶음과 40장을 합친다면 (10 + 20) + (30 + 40) = 100번의
# 비교가 필요하다. 그러나 10장과 40장을 합친 뒤, 한친 50장 묶음과
# 20장을 합친다면 (10 + 40) + (50 + 20) = 120번의 비교가 필요하므로
# 덜 효율적인 방법이다
# N개의 숫자 카드 묶음의 각각의 크기가 주어질 때 최소한 몇 번의
# 비교가 필요한지를 구하라

# 첫째 줄에 N이 주어진다
# 이어서 N개의 줄에 걸쳐 숫자 카드 묶음의 각각의 크기가 주어진다

# 첫째 줄에 최소 비교 횟수를 출력

import heapq, sys

N = int(sys.stdin.readline())
cards = []
for _ in range(N):
    # 카드 묶음의 크기를 추가
    heapq.heappush(cards, int(sys.stdin.readline()))
res = 0
# 카드 묶음이 하나 남을 때까지 합치기
while len(cards) > 1:
    # 가장 작은 두 카드 묶음을 꺼내 합침
    a = heapq.heappop(cards)
    b = heapq.heappop(cards)
    # 합쳐진 결과를 다시 heapq에 추가
    heapq.heappush(cards, a + b)
    # 비교 횟수 누적
    res += a + b
# 최종적으로 누적된 비교 횟수 출력
print(res)



# 이 문제는 최소 비교 횟수를 구하는 것이 목표이기 때문에
# 각 카드 묶음을 비교하는 것보다 카드 묶음을 합치는
# 횟수를 최소화해야 한다.
# 따라서, 가장 작은 묶음 두 개를 합쳐가며 최종적으로
# 하나의 카드 묶음으로 만들어 나가는 것이 가장 효율적이다
# 이렇게 작은 묶음부터 합쳐가면, 두 카드 묶음 A와 B가 있을 때
# A + B보다 큰 카드 묶음 C가 존재한다면, A와 B를 
# 합치는 것보다 C와 A + B를 합치는 것이 더 효율적이다
# 이를 구현하기 위해 heap 자료구조를 사용한다.
# heap 자료구조는 작은 값부터 우선순위가 높게 정렬된
# 구조이므로, 가장 작은 카드 묶음 두 개를 빠르게 찾을 수 있다
# 또한 heap 자료구조에서 push와 pop 연산이 모두
# O(logN)의 시간 복잡도를 가지기 때문에, 전체적인
# 시간복잡도도 O(NlogN)으로 매우 효율적이다