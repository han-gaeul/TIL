# 1463

# 정수 X에 사용할 수 있는 연산은 다음과 같이 세가지이다
# 1. X가 3으로 나누어 떨어지면 3으로 나눈다
# 2. X가 2로 나누어 떨어지면 2로 나눈다
# 3. 1을 뺀다
# 정수 N이 주어졌을 때 위와 같은 연산 세 개를 적절히 사용해서
# 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력

# 첫째 줄에 1보다 크거나 같고 10의 6승보다 작거나 같은 정수 N이 주어진다

# 첫째 줄에 연산을 하는 횟수의 최솟값을 출력

N = int(input())
li = [0] * (N + 1)
for i in range(2, N + 1):
    li[i] = li[i - 1] + 1
    if i % 3 == 0:
        li[i] = min(li[i], li[i // 3] + 1)
    if i % 2 == 0:
        li[i] = min(li[i], li[i // 2] + 1)
print(li[N])


# 다이나믹 프로그래밍을 사용해 N부터 1까지의 값을 차례로 계산하며
# li 리스트에 저장한다. li[i]는 i를 1로 만들기 위한 최소 연산 횟수를 의미한다
# i를 1로 만들기 위해서는 i - 1을 1로 만들고 1을 더하는 방법이
# 최소 연산 횟수가 된다. 그러나 i가 2 또는 3으로 나누어 떨어지는 경우
# i를 2 또는 3으로 나누어서 만들 수 있는 수를 이용하는 것이
# 더 적은 연산 횟수를 필요로 하므로 이를 고려해 li[i]를 갱신한다

# 다이나믹 프로그래밍을 사용하는 이유는 중복 계산을 방지하기 위해서이다
# 예를 들어 N = 10인 경우, 10을 1로 만들기 위한 최소 연산 횟수를
# 구하려면 다음과 같은 과정을 거친다
# 10 > 9 > 3 > 1 (3번 연산)
# 이때, 9를 1로 만들기 위한 최소 연산 횟수는 이미 구해졌다
# 따라서 10 > 9의 경우의 수를 계산할 때는 이전에 구한 최소 연산
# 횟수를 사용하면 된다.
# 이 코드에서는 li 리스트를 이용해 중복 계산을 방지하고
# 최소 연산 횟수를 구한다. li[i]는 i를 1로 만들기 위한 최소 연산
# 횟수를 의미한다. 먼저 li[2]부터 li[N]까지 차례로 계산하면서
# 다음과 같은 방법으로 li[i] 값을 갱신한다
# li[i - 1] + 1 : i - 1을 1로 만든 후 1을 더하는 방법을 이용하는 경우의
# 최소 연산 횟수
# li[i // 2] + 1 : i를 2로 나눈 후 2를 곱해서 i를 만드는 방법을 이용하는
# 경우의 최소 연산 횟수
# li[i // 3] + 1 : i를 3으로 나눈 후 3을 곱해서 i를 만드는 방법을
# 이용하는 경우의 최소 연산 횟수
# 위 세 가지 방법 중에서 가장 작은 값을 li[i]에 대입한다.
# 이를 통해 li[N]에는 N을 1로 만드는데 필요한 최소 연산 횟수가
# 저장된다. 이때, 다이나믹 프로그래밍을 사용함으로써 중복 계산을
# 방지하여 효율적인 알고리즘을 구현할 수 있다.