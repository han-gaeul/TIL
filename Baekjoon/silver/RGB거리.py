# 1149

# RGB 거리에는 집이 N개 있다
# 거리는 선분으로 나타낼 수 있고 1번 집부터 N번 집이 순서대로 있다
# 집은 빨강, 초록, 파랑 중 하나의 색으로 칠해야 한다
# 각각의 집을 빨강, 초록, 파랑으로 칠하는 비용이 주어졌을 때
# 아래 규칙을 만족하면서 모든 집을 칠하는 비용의 최솟값을 구해보자
# 1번 집의 색은 2번 집의 색과 같지 않아야 한다
# N번 집의 색은 N - 1번 집의 색과 같지 않아야 한다
# i번 집의 색은 i - 1번, i + 1번 집의 색과 같지 않아야 한다

# 첫째 줄에 집의 수 N이 주어진다
# 둘째 줄부터 N개의 줄에는 각 집을 빨강, 초록, 파랑으로 칠하는 비용이
# 1번 집부터 한 줄에 하나씩 주어진다

# 첫째 줄에 모든 집을 칠하는 비용의 최솟값을 출력

N = int(input())
house = [list(map(int, input().split())) for _ in range(N)]
for i in range(1, len(house)):
    # i번째 집을 빨강으로 칠할 경우
    # i - 1번째 집을 초록, 파랑으로 칠한 경우 중 최솟값을 더함
    house[i][0] += min(house[i - 1][1], house[i - 1][2])
    # i번째 집을 초록으로 칠할 경우
    # i - 1번째 집을 빨강, 파랑으로 칠한 경우 중 최솟값을 더함
    house[i][1] += min(house[i - 1][0], house[i - 1][2])
    # i번째 집을 파랑으로 칠할 경우
    # i - 1번째 집을 빨강, 초록으로 칠한 경우 중 최솟값을 더함
    house[i][2] += min(house[i - 1][0], house[i - 1][1])
# 최솟값 출력
print(min(house[-1]))


# 다이나믹 프로그래밍(DP)는 하나의 문제를 작은 문제로 쪼개어
# 해결하는 알고리즘이다.
# 문제에서는 각 집을 빨강, 초록, 파랑 ㅂ중 하나로 칠하는 비용이
# 주어졌을 때 인접한 집들이 같은 색으로 칠해지지 않도록 하면서
# 모든 집을 칠하는데 드는 최소 비용을 구해야 한다
# house[i][j]는 i번째 집을 j번째 색으로 칠했을 때
# 1 ~ i번째 집을 모두 칠하는 데에 드는 최소비용을 의미한다
# 그러면 house[i][j]를 구하기 위해서 house[i - 1][j]에서
# i번째 집을 칠하는 비용을 더해야 한다
# 이전 집을 칠한 색과 현재 집을 칠하는 색이 같으면 안 되므로
# 각 색깔마다 이전 집을 다른 색깔로 칠한 경우의 최소 비용을 구해야 한다
# 예를 들어, 이전 집을 초록으로 칠했다면 현재 집을 빨강 또는
# 파랑으로 칠할 수 있다. 따라서 이전 집을 초록으로 칠했을 떄의
# 최소 비용과 이전 집을 파랑으로 칠했을 때의 최소 비용 중에서
# 더 작은 값을 현재 집을 초록으로 칠할 때의 비용에 더한다.
# 이와 같은 방법으로 리스트를 채워나가면서 마지막 집까지 모두
# 칠했을 때 드는 최소 비용을 구할 수 있다.