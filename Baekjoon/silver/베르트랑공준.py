# 4948

# 베르트랑 공준은 임의의 자연수 n에 대하여 n보다 크고 2n보다 작거나 같은 소수는 적어도 하나 존재한다는 내용
# 이 명제는 조제프 베르트랑이 1845년에 추측했고 파프누티 체비쇼프가 1850년에 증명했다
# 예를 들어 10보다 크고 20보다 작거나 같은 소수는 4개가 있다. (11, 13, 17, 19)
# 또 14보다 크고 28보다 작거나 같은 소수는 3개가 있다 (17, 19, 23)
# 자연수 n이 주어졌을 때 n보다 크고 2n보다 작거나 같은 소수의 개수를 구하라

# 입력은 여러 개의 테스트 케이스로 이루어져 있다
# 각 케이스는 n을 포함하는 한 줄로 이루어져 있다
# 입력의 마지막에는 0이 주어진다

# 각 테스트 케이스에 대해서 n보다 크고 2n보다 작거나 같은 소수의 개수를 출력


# 에라토스테네스의 체
import math

arr = [1] * (2 * 123457)
arr[0], arr[1] = 0
# 2부터 arr 길이의 제곱근까지 반복
for i in range(2, int(math.sqrt(len(arr)))):
    if arr[i]:
        # i + i부터 len(arr)까지 i의 배수를 건너뛰며
        # arr[j]를 0으로 초기화
        for j in range(i + i, len(arr), i):
            arr[j] = 0
# 0이 입력될 때까지 반복
while True:
    n = int(input())
    if n == 0:
        break
    else:
        # n + 1부터 2 * n + 1까지 arr의 합을 구함
        print(sum(arr[n + 1 : (2 * n) + 1]))

# math.sqrt(x) 함수는 x의 제곱근을 반환
# 반환형은 float 타입. 인자로 음수가 들어오게 되면 에러 발생



# n의 범위가 123456까지이므로
# 2n의 범위까지 배열 만들기
check = [0] * 2 + [1] * 246912
for i in range(2, 246913):
    if check[i]:
        # i * 2부터 246913까지 i의 배수를 건너뛰며
        # check[j]를 0으로 초기화
        for j in range(i * 2, 246913, i):
            check[j] = 0
# 0이 입력될 때까지 반복
while True:
    n = int(input())
    if n == 0:
        break
    # n + 1부터 n * 2 + 1까지 check의 합을 구함
    print(sum(check[n + 1 : n * 2 + 1]))