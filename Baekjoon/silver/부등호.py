# 2529

# 두 종류의 부등호 기호 '<'와 '>'가 k개 나열된 순서열 A가 있다
# 우리는 이 부등호 기호 앞뒤에 서로 다른 한 자릿수 숫자를 넣어서
# 모든 부등호 관계를 만족시키려고 한다
# 예를 들어, 제시된 부등호 순서열 A가 다음과 같다고 하자
# A -> <<<><<><>
# 부등호 기호 앞뒤에 넣을 수 있는 숫자는 0부터 9까지의 정수이며
# 선택된 숫자는 모두 달라야 한다. 아래는 부등호 순서열 A를
# 만족시키는 한 예이다
# 3 < 4 < 5 < 6 > 1 < 2 < 8 < 7 < 9 < 0
# 이 상황에서 부등호 기호를 제거한 뒤, 숫자를 모두 붙이면
# 하나의 수를 만들 수 있는데 이 수를 주어진 부등호 관계를
# 만족시키는 정수라고 한다. 그런데 주어진 부등호 관계를 
# 만족하는 정수는 하나 이상 존재한다. 예를 들어
# 3456128790 뿐만 아니라 5689023174도 아래와 같이
# 부등호 관계 A를 만족시킨다.
# 5 < 6 < 8 < 9 > 0 < 2 < 3 > 1 < 7 > 4
# 제시된 k개의 부등호 순서를 만족하는 (k + 1)자리의 정수 중에서
# 최댓값과 최솟값을 찾아야 한다. 앞서 설명한대로 각 부등호의
# 앞뒤에 들어가는 숫자는 {0, 1, 2, 3, 4, 5, 6, 7, 8, 9} 중에서
# 선택해야 하며 선택된 숫자는 모두 달라야 한다

# 첫 줄에 부등호 문자의 개수를 나타내는 정수 k가 주어진다
# 그 다음 줄에는 k개의 부등호 기호가 하나의 공백을 두고
# 한 줄에 모두 제시된다

# 여러분은 제시된 부등호 관계를 만족하는 k + 1 자리의 최대, 최소
# 정수를 첫째 줄과 둘째 줄에 각각 출력해야 한다
# 단, 첫 자리가 0인 경우도 정수에 포함되어야 한다
# 모든 입력에 답은 항상 존재하며 출력 정수는 하나의 문자열이 되도록 해야 한다

k = int(input())
inequalities = list(input().split())
# 사용한 숫자 체크 리스트
visited = [0] * 10
# 가능한 정수 리스트
ans = []
# 부등호 관계를 만족하는지 확인하는 함수
def check(x, y, op):
    if op == '<':
        if x > y:
            return False
    elif op == '>':
        if x < y:
            return False
    return True
# 깊이 우선 탐색 함수
def dfs(cnt, num):
    # 숫자를 다 선택한 경우
    if cnt == k + 1:
        # 가능한 정수 리스트에 추가
        ans.append(num)
        return
    # 0부터 9까지의 숫자에 대해 검사
    for i in range(10):
        # 이미 사용한 숫자인 경우
        if visited[i]:
            continue
        # 부등호 관계를 만족하는지 확인
        if cnt == 0 or check(num[cnt - 1], str(i), inequalities[cnt - 1]):
            # 사용한 숫자 체크
            visited[i] = 1
            # 다음 숫자를 선택하기 위해 탐색
            dfs(cnt + 1, num + str(i))
            # 사용한 숫자 체크 해제
            visited[i] = 0
dfs(0, '')
# 가능한 정수 리스트를 정렬하여 최댓값, 최솟값 출력
ans.sort()
print(ans[-1], ans[0], sep='\n')