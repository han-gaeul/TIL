### `시간 복잡도 & 빅오 표기법`

-----------

#### 🔎 알고리즘의 시간 복잡도

좋은 알고리즘이란? == input을 넣은 후 output이 나오는 **시간**이 짧은 알고리즘!

개개인의 컴퓨팅 환경에 따라 **같은 알고리즘이라도 측정 시간이 다르다.**

환경에 영향을 받지 않는 **객관적인 기준**이 필요

![](/Users/goobano/Desktop/TIL/DataStructure/data_structure/algorithm.png)

객관적인 측정을 위해 알고리즘 내부에서 **기본연산**이 **몇 번** 일어나는지 살펴본다.



```python
def count(word, char):
  total = 0
  
  for i in word:
    if i == char:
      total += 1
      
  return total
```

기본연산 : 단위 시간 1이 소요되는 연산

> ex) 할당, 산술, 비교, 반환 ...

**기본연산의 총 횟수 == 알고리즘의 소요 시간**



위와 같은 상황에서 몇 번의 기본연산이 일어날까? (== 알고리즘의 소요시간이 몇일까?)

> count('apple', 'p')
>
> ➡︎ 2



기본 연산의 횟수를 구하는 것은 환경에 영향을 받지 않는 객관적인 방법이지만

**입력 개수**에 따라 시간이 달라진다는 문제가 있음

"catcat"이라면?

"abcdefghijklmnopqrstuvwxyz" 라면?



따라서 성능을 측정할 때는 **입력을 통일**시킴

가장 기본연산이 많이 일어나는 **최악의 입력 n개**가 들어온다고 가정

<최악의 입력 n개 ➡︎ 매 반복마다 totla += 1 연산 실행>



입력 n개에 따른 소요 시간을 수식으로 세울 수 있음

<입력 n개에 따른 소요 시간 == 시간 복잡도(Time Complexity)>





##### `시간 복잡도 (Time Complexity)`

- 계산 복잡도 이론에서 시간 복잡도는 문제를 해결하는데 걸리는 시간과 입력의 함수 관계를 가리킴
- 단순하게 **알고리즘의 수행 시간**을 의미한다고
  - 시간 복잡도가 높다 ➡︎ 느린 알고리즘
  - 시간 복잡도가 낮다 ➡︎ 빠른 알고리즘



#### 🔎 빅오(Big-O) 표기법

##### `빅오(Big-O) 표기법이란?`

- 입력 n이 **무한대**로 커진다고 가정하고 시간 복잡도를 간단하게 표시하는 것

  **최고차항**만 남기고 계수와 상수 제거

- 다양한 시간 복잡도 종류 살펴보기

![](/Users/goobano/Desktop/TIL/DataStructure/data_structure/big_o.jpeg)



`O(1)` 단순 산술 계산(덧셈, 뺄셈, 곱셈, 나눗셈) ➡︎ a + b, 100 * 200

`O(logN)` 크기 N인 리스트를 반절씩 순회/탐색 ➡︎ 이진탐색(Binary Search), 분할정복(Divide & Conquer)

`O(N)` 크기 N인 리스트를 순회 ➡︎ 리스트 순회, 1중 for문

`O(NlogN)` 크기 N인 리스트를 반절씩 탐색 * 순회 ➡︎ 높은 성능의 정렬(Merge/Quick/Heap Sort)

`O(N^2)` 크기 M, N인 2중 리스트를 순회 ➡︎ 2중 리스트 순회, 2중 for문

`O(N^3)` 3중 리스트를 순회 ➡︎ 3중 리스트 순회, 3중 for문

`O(2^N)` 크기 N 집합의 부분 집합 ➡︎ 크기가 N인 집합의 부분 집합

`O(N!)` 크기 N 리스트의 순열 ➡︎ 크기가 N인 순열



- 예시

  - 첫 번째 방법 - 1부터 n까지 일일히 더하기

  ```python
  def get_total(n):
    total = 0
    
    for i in range(1, n + 1):
      total += 1
    
    return total
  
  print(get_total(10))
  >>> 55
  
  print(get_total(100000000))
  >>> 제한시간 1초 초과
  ```

  - 두 번째 방법 - 가우스의 합 공식

  ```python
  def get_total(n):
    return (n * (n + 1) // 2)
  
  print(get_total(10))
  >>> 55
  
  print(get_total(10000000))
  >>> 500000000500000000
  ```

  

💡 같은 Output을 만드는 알고리즘이라도 시간 복잡도에 따라 **성능**이 달라질수 있고

​	  **정답 여부**가 갈리는 포인트가 됨



- 내장 함수, 메서드의 시간 복잡도도 확인할 필요가 있음

  - for문을 1번만 썼는데 왜 시간초과가 날까?

    ➡︎ for문이 1번이라고 해서 무조건 O(n)인 것은 아님

    ​	for문 안에 O(n) 내장 함수를 사용했다면 사실상 **이중 for문**과 다를 것이 없음