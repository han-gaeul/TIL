# 휴대폰의 자판은 컴퓨터 키보드 자판과는 다르게 하나의 키에
# 여러 개의 문자가 할당될 수 있다. 키 하나에 여러 문자가
# 할당된 경우, 동일한 키를 연속해서 빠르게 누르면 할당된 순서대로
# 문자가 바뀐다.
# 예를 들어, 1번 키에 'A', 'B', 'C' 순서대로 문자가 할당되어 있다면
# 1번 키를 한 번 누르면 'A', 두 번 누르면 'B', 세 번 누르면 'C'가 된다
# 같은 규칙을 적용해 아무렇게나 만든 휴대폰 자판이 있다
# 이 휴대폰 자판은 키의 개수가 1개부터 최대 100개까지 있을 수 있으며
# 특정 키를 눌렀을 때 입력되는 문자들도 무작위로 배열되어 있다
# 또, 같은 문자가 자판 전체에 여러 ㅂ너 할당된 경우도 있고, 키 하나에
# 같은 문자가 여러 번 할당된 경우도 있다. 심지어 아예 할당되지 않은
# 경우도 있다. 따라서 몇몇 문자열은 작성할 수 없을 수도 있다
# 이 휴대폰 자판을 이용해 특정 문자열을 작성할 때, 키를 최소 몇 번
# 눌러야 그 문자열을 작성할 수 있는지 알아보고자 한다.
# 1번 키부터 차례대로 할당된 문자들이 순서대로 담긴 문자열배열
# keymap과 입력하려는 문자열들이 담긴 문자열 배열 targets가
# 주어질 때, 각 문자열을 작성하기 위해 키를 최소 몇 번씩 눌러야
# 하는지 순서대로 배열에 담아 return
# 단 목표 문자열을 작성할 수 없을 때는 -1 저장

def solution(keymap, targets):
    keytable = {}
    for keys in keymap:
        for i, key in enumerate(keys):
            if key not in keytable:
                keytable[key] = i + 1
            else:
                keytable[key] = min(keytable[key], i + 1)
    answer = []
    for target in targets:
        clicked = 0
        for key in target:
            if key not in keytable:
                clicked = -1
                break
            clicked += keytable[key]
        answer.append(clicked)
    return answer



# keytable은 주어진 keymap에서 각 문자 키의 위치를 찾아 저장한다.
# 예를 들어, keymap이 다음과 같다고 가정해보자
# keymap = ['qwertyuiop', 'asdfghjkl', 'zxcvbnm']
# 이 경우 keytable은 다음과 같다
# keytable = {'q': 1, 'w': 2, 'e': 3, 'r': 4, 't': 5, 'y': 6, 'u': 7, 'i': 8, 'o': 9,
# 'p': 10, 'a': 1, 's': 2, 'd': 3, 'f': 4, 'g': 5, 'h': 6, 'j': 7, 'k': 8, 'l': 9, 'z': 1,
# 'x': 2, 'c': 3, 'v': 4, 'b': 5, 'n': 6, 'm': 7}
# 이 keytable은 모든 문자 키에 대해 해당 문자열에서 위치를 저장한다.
# 각 문자열에서 가장 왼쪽에 있는 문자의 위치는 1, 그 다음 문자는 2
# 처럼 증가한다. 예를 들어, 'q'는 첫번째 열의 첫번째 문자이므로
# 위치는 1이다.

# 각 타겟 문자열에서 클릭하는데 필요한 총 클릭 수를 계산하기 위해
# 문자열에서 한 문자씩 처리한다. 각 문자의 위치를
# keytable에서 찾아 해당 위치의 값을 클릭 수에 추가한다
# 예를 들어, 'hello'를 클릭하는데 필요한 클릭 수는 다음과 같다
# 클릭 수 = keytable['h'] + keytable['e'] + keytable['l']
# + keytable['l'] + keytable['o']
# 여기서 h의 위치는 6번째 열의 첫번째 문자이므로 keytable['h'] 
# 값은 6이다. 'e'의 위치는 두번째 열의 첫번째 문자이므로
# keytable['e']의 값은 1이다.
# 따라서 'hello'를 클릭하는데 필요한 클릭 수는 6 + 1 + 2 + 2 + 7
# = 18이다

# 마지막으로 각 타겟 문자열에서 클릭하는데 필요한 총 클릭 수를
# 계산해 목록에 추가하고, 이를 반환한다.
# 예를 들어, ['hello', 'world']라는 두 개의 타겟 문자열이 주어지면
# 함수는 [18, 21]이라는 목록을 반환한다.