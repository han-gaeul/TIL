# 코딩테스트를 준비하는 머쓱이는 프로그래머스에서 문제를 풀고
# 나중에 다시 코드를 보면서 공부하려고 작성한 코드를 컴퓨터
# 바탕화면에 아무 위치에나 저장해둔다. 저장한 코드가 많아지면서
# 머쓱이는 본인의 컴퓨터 바탕화면이 너무 지저분하다고 생각했다
# 프로그래머스에서 작성했던 코드는 그 문제에 가서 다시 볼 수 
# 있기 때문에 저장해 둔 파일들을 전부 삭제하기로 했다
# 컴퓨터 바탕화면은 각 칸이 정사각형인 격자판이다. 이때 컴퓨터
# 바탕화면의 상태를 나타낸 문자열 배열 wallpaper가 주어진다
# 파일들은 바탕화면의 격자칸에 위치하고 바탕화면의 격자점들은
# 바탕화면의 가장 왼쪽 위 (0, 0)으로 시작해 (세로 좌표, 가로 좌표)로
# 표현한다. 빈칸은 '.', 파일이 있는 칸은 '#'의 값을 가진다
# 드래그를 하면 파일들을 선택할 수 있고, 선택된 파이들을 삭제할 수 있다
# 머쓱이는 최소한의 이동거리를 갖는 한 번의 드래그로 모든 파일을
# 선택해서 한 번에 지우려고 하며 드래그로 파일들을 선택하는
# 방법은 다음과 같다
# 드래그는 바탕화면의 격자점 S(lux, luy)를 마우스 왼쪽 버튼으로 
# 클릭한 상태로 격자점 E(rdx, rdy)로 이동한 뒤 마우스 왼쪽 버튼을
# 떼는 행동이다. 이때, 점 S에서 점 E로 드래고한다, 고 표현하고
# 점 S와 점 E를 각각 드래그의 시작점, 끝점이라고 표현한다.
# 점 S(lux, luy)에서 점 E(rdx, rdy)로 드래그할 때, 드래그 한 거리는
# |rdx - lux| + |rdy - luy|로 정의한다
# 점 S에서 점 E로 드래그를 하면 바탕화면에서 두 격자점을 각각
# 왼쪽 위, 오른쪽 아래로 하는 직사각형 내부에 있는 모든 파일이
# 선택 된다.
# 머쓱이의 컴퓨터 바탕화면의 상태를 나타내는 문자열 배열 wallpaper가
# 매개변수로 주어질 때 바탕화면의 파일들을 한 번에 삭제하기 위해
# 최소한의 이동거리를 갖는 드래그의 시작점과 끝점을 담은
# 정수 배열을 return
# 드래그의 시작점이 (lux, luy), 끝점이 (rdx, rdy)라면 정수 배열
# [lux, luy, rdx, rdy]를 return

def solution(wallpaper):
    # 각 row, column에서 '#'이 위치한 인덱스를 담을 리스트 초기화
    a, b = [], []
    # wallpaper의 각 row에 대해 반복
    for i in range(len(wallpaper)):
        # wallpaper의 각 column에 대해 반복
        for j in range(len(wallpaper[i])):
            if wallpaper[i][j] == '#':
                # 해당 row의 인덱스 i를 a 리스트에 추가
                a.append(i)
                # 해당 column의 인덱스 i를 b 리스트에 추가
                b.append(j)
    return [min(a), min(b), max(a) + 1, max(b) + 1]



# 주어진 문자열 형태의 바탕화면 모양에서 '#'으로 표시된 영역의
# 위치 정보를 추출하는 코드이다.
# 우선, 이중 for문을 사용해 문자열의 각 위치를 하나씩 확인한다
# 그리고 해당 위치에 '#'이 있으면 그 위치의 row 인덱스와
# column 인덱스를 a, b 리스트에 각각 추가한다.
# 이 과정을 거치면 a 리스트에는 '#'이 위치한 row 번호들이,
# b 리스트에는 '#'이 위치한 column 번호들이 저장된다
# 마지막으로, a, b 리스트에서 최소값과 최대값을 찾아 각각
# 바탕화면의 좌측 상단과 우측 하단 꼭지점의 위치를 구한다

# 최대값에 1을 더하는 이유는 리스트의 인덱스는 0부터 시작하기 때문이다
# 예를 들어, 만약 wallpaper의 가장 오른쪽 아래에 위치한 '#'의 위치
# 인덱스가 (4, 6)이라면, 실제로는 (5, 7)까지 포함된 영역을 차지하게 된다
# 즉, max(a)와 max(b)는 각각 행과 열에서의 가장 큰 인덱스를
# 의미하는데, 이 값에 1을 더함으로써 실제 영역의 크기를 구할 수 있다